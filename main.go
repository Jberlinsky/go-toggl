/*

Package toggl provides an API for interacting with the Toggl time tracking service.

See https://github.com/toggl/toggl_api_docs for more information on Toggl's REST API.

*/
package toggl

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"time"
)

const (
	TogglApi       = "https://toggl.com/api/v8"
	ReportsApi     = "https://toggl.com/reports/api/v2"
	DefaultAppName = "go-toggl"
)

var client = &http.Client{}

// AppName is the application name used when creating timers.
var AppName = DefaultAppName

// structures ///////////////////////////

// Session represents an active connection to the Toggl REST API.
type Session struct {
	ApiToken string
	username string
	password string
}

// Account represents a user account.
type Account struct {
	Data struct {
		ApiToken    string      `json:"api_token"`
		Timezone    string      `json:"timezone"`
		Id          int         `json:"id"`
		Workspaces  []Workspace `json:"workspaces"`
		Projects    []Project   `json:"projects"`
		Tags        []Tag       `json:"tags"`
		TimeEntries []TimeEntry `json:"time_entries"`
	} `json:"data"`
	Since int `json:"since"`
}

// Workspace represents a user workspace.
type Workspace struct {
	Id              int    `json:"id"`
	RoundingMinutes int    `json:"rounding_minutes"`
	Rounding        int    `json:"rounding"`
	Name            string `json:"name"`
}

// Project represents a project.
type Project struct {
	Wid  int    `json:"wid"`
	Id   int    `json:"id"`
	Name string `json:"name"`
}

// Tag represents a tag.
type Tag struct {
	Wid  int    `json:"wid"`
	Id   int    `json:"id"`
	Name string `json:"name"`
}

// TimeEntry represents a single time entry.
type TimeEntry struct {
	Wid         int        `json:"wid,omitempty"`
	Id          int        `json:"id,omitempty"`
	Pid         int        `json:"pid,omitempty"`
	Description string     `json:"description,omitempty"`
	Stop        *time.Time `json:"stop,omitempty"`
	Start       *time.Time `json:"start,omitempty"`
	Tags        []string   `json:"tags"`
	Duration    int        `json:"duration,omitempty"`
}

// SummaryReport represents a summary report generated by Toggl's reporting API.
type SummaryReport struct {
	TotalGrand int `json:"total_grand"`
	Data       []struct {
		Id    int `json:"id"`
		Time  int `json:"time"`
		Title struct {
			Project string `json:"project"`
			Client  string `json:"client"`
		} `json:"title"`
		Items []struct {
			Title map[string]string `json:"title"`
			Time  int               `json:"time"`
		} `json:"items"`
	} `json:"data"`
}

// functions ////////////////////////////

// OpenSession opens a session using an existing API token.
func OpenSession(apiToken string) Session {
	return Session{ApiToken: apiToken}
}

// NewSession creates a new session by retrieving a user's API token.
func NewSession(username, password string) (session Session, err error) {
	session.username = username
	session.password = password

	data, err := session.get(TogglApi, "/me", nil)
	if err != nil {
		return session, err
	}

	var account Account
	err = decodeAccount(data, &account)
	if err != nil {
		return session, err
	}

	session.username = ""
	session.password = ""
	session.ApiToken = account.Data.ApiToken

	return session, nil
}

// GetAccount returns a user's account information, including a list of active
// projects and timers.
func (session *Session) GetAccount() (Account, error) {
	params := map[string]string{"with_related_data": "true"}
	data, err := session.get(TogglApi, "/me", params)
	if err != nil {
		return Account{}, err
	}

	var account Account
	err = decodeAccount(data, &account)
	return account, err
}

// GetSummaryReport retrieves a summary report using Toggle's reporting API.
func (session *Session) GetSummaryReport(workspace int, since, until string) (SummaryReport, error) {
	params := map[string]string{
		"user_agent":   "jc-toggl",
		"grouping":     "projects",
		"since":        since,
		"until":        until,
		"rounding":     "on",
		"workspace_id": fmt.Sprintf("%d", workspace)}
	data, err := session.get(ReportsApi, "/summary", params)
	if err != nil {
		return SummaryReport{}, err
	}
	log.Printf("Got data: %s", data)

	var report SummaryReport
	err = decodeSummaryReport(data, &report)
	return report, err
}

// GetSummaryReport retrieves a summary report using Toggle's reporting API.
func (session *Session) StartTimeEntry(description string) (TimeEntry, error) {
	data := map[string]interface{}{
		"time_entry": map[string]string{
			"description":  description,
			"created_with": AppName,
		},
	}
	respData, err := session.post(TogglApi, "/time_entries/start", data)
	return timeEntryRequest(respData, err)
}

// StartTimeEntryForProject creates a new time entry for a specific project.
func (session *Session) StartTimeEntryForProject(description string, projectId int) (TimeEntry, error) {
	data := map[string]interface{}{
		"time_entry": map[string]interface{}{
			"description":  description,
			"pid":          projectId,
			"created_with": AppName,
		},
	}
	respData, err := session.post(TogglApi, "/time_entries/start", data)
	return timeEntryRequest(respData, err)
}

// UpdateTimeEntry changes information about an existing time entry.
func (session *Session) UpdateTimeEntry(timer TimeEntry) (TimeEntry, error) {
	log.Printf("Updating timer %v", timer)
	data := map[string]interface{}{
		"time_entry": timer,
	}
	path := fmt.Sprintf("/time_entries/%v", timer.Id)
	respData, err := session.post(TogglApi, path, data)
	return timeEntryRequest(respData, err)
}

// ContinueTimeEntry creates a new time entry based on an existing entry. The
// new entry will have the same description and project ID as the existing one.
func (session *Session) ContinueTimeEntry(timer TimeEntry) (TimeEntry, error) {
	log.Printf("Continuing timer %v", timer)
	data := map[string]interface{}{
		"time_entry": map[string]interface{}{
			"description":  timer.Description,
			"pid":          timer.Pid,
			"created_with": AppName,
		},
	}
	respData, err := session.post(TogglApi, "/time_entries/start", data)
	return timeEntryRequest(respData, err)
}

// StopTimeEntry stops a running time entry.
func (session *Session) StopTimeEntry(timer TimeEntry) (TimeEntry, error) {
	log.Printf("Stopping timer %v", timer)
	path := fmt.Sprintf("/time_entries/%v/stop", timer.Id)
	respData, err := session.put(TogglApi, path, nil)
	return timeEntryRequest(respData, err)
}

func (session *Session) AddRemoveTag(entryId int, tag string, add bool) (TimeEntry, error) {
	log.Printf("Adding tag to time entry %v", entryId)

	action := "add"
	if !add {
		action = "remove"
	}

	data := map[string]interface{}{
		"time_entry": map[string]interface{}{
			"tags":       []string{tag},
			"tag_action": action,
		},
	}
	path := fmt.Sprintf("/time_entries/%v", entryId)
	respData, err := session.post(TogglApi, path, data)

	return timeEntryRequest(respData, err)
}

// DeleteTimeEntry deletes a time entry.
func (session *Session) DeleteTimeEntry(timer TimeEntry) ([]byte, error) {
	log.Printf("Deleting timer %v", timer)
	path := fmt.Sprintf("/time_entries/%v", timer.Id)
	return session.delete(TogglApi, path)
}

// IsRunning returns true if the receiver is currently running.
func (timer *TimeEntry) IsRunning() bool {
	return timer.Duration < 0
}

// CreateProject creates a new project.
func (session *Session) CreateProject(name string, wid int) (proj Project, err error) {
	log.Printf("Creating project %s", name)
	data := map[string]interface{}{
		"project": map[string]interface{}{
			"name": name,
			"wid":  wid,
		},
	}

	respData, err := session.post(TogglApi, "/projects", data)
	if err != nil {
		return proj, err
	}

	var entry struct {
		Data Project `json:"data"`
	}
	err = json.Unmarshal(respData, &entry)
	log.Printf("Unmarshaled '%s' into %#v\n", respData, entry)
	if err != nil {
		return proj, err
	}

	return entry.Data, nil
}

// UpdateProject changes information about an existing project.
func (session *Session) UpdateProject(project Project) (Project, error) {
	log.Printf("Updating project %v", project)
	data := map[string]interface{}{
		"project": project,
	}
	path := fmt.Sprintf("/projects/%v", project.Id)
	respData, err := session.put(TogglApi, path, data)

	if err != nil {
		return Project{}, err
	}

	var entry struct {
		Data Project `json:"data"`
	}
	err = json.Unmarshal(respData, &entry)
	log.Printf("Unmarshaled '%s' into %#v\n", data, entry)
	if err != nil {
		return Project{}, err
	}

	return entry.Data, nil
}

// DeleteProject deletes a project.
func (session *Session) DeleteProject(project Project) ([]byte, error) {
	log.Printf("Deleting project %v", project)
	path := fmt.Sprintf("/projects/%v", project.Id)
	return session.delete(TogglApi, path)
}

// CreateTag creates a new tag.
func (session *Session) CreateTag(name string, wid int) (proj Tag, err error) {
	log.Printf("Creating tag %s", name)
	data := map[string]interface{}{
		"tag": map[string]interface{}{
			"name": name,
			"wid":  wid,
		},
	}

	respData, err := session.post(TogglApi, "/tags", data)
	if err != nil {
		return proj, err
	}

	var entry struct {
		Data Tag `json:"data"`
	}
	err = json.Unmarshal(respData, &entry)
	log.Printf("Unmarshaled '%s' into %#v\n", respData, entry)
	if err != nil {
		return proj, err
	}

	return entry.Data, nil
}

// UpdateTag changes information about an existing tag.
func (session *Session) UpdateTag(tag Tag) (Tag, error) {
	log.Printf("Updating tag %v", tag)
	data := map[string]interface{}{
		"tag": tag,
	}
	path := fmt.Sprintf("/tags/%v", tag.Id)
	respData, err := session.put(TogglApi, path, data)

	if err != nil {
		return Tag{}, err
	}

	var entry struct {
		Data Tag `json:"data"`
	}
	err = json.Unmarshal(respData, &entry)
	log.Printf("Unmarshaled '%s' into %#v\n", data, entry)
	if err != nil {
		return Tag{}, err
	}

	return entry.Data, nil
}

// DeleteTag deletes a tag.
func (session *Session) DeleteTag(tag Tag) ([]byte, error) {
	log.Printf("Deleting tag %v", tag)
	path := fmt.Sprintf("/tags/%v", tag.Id)
	return session.delete(TogglApi, path)
}

func (e *TimeEntry) StartTime() time.Time {
	if e.Start != nil {
		return *e.Start
	}
	return time.Time{}
}

func (e *TimeEntry) StopTime() time.Time {
	if e.Stop != nil {
		return *e.Stop
	}
	return time.Time{}
}

func (e *TimeEntry) HasTag(tag string) bool {
	for _, t := range e.Tags {
		if t == tag {
			return true
		}
	}
	return false
}

// UnmarshalJSON unmarshals a TimeEntry from JSON data, converting timestamp
// fields to Go Time values.
func (t *TimeEntry) UnmarshalJSON(b []byte) error {
	var entry tempTimeEntry
	err := json.Unmarshal(b, &entry)
	if err != nil {
		return err
	}
	te, err := entry.asTimeEntry()
	if err != nil {
		return err
	}
	*t = te
	return nil
}

// support /////////////////////////////////////////////////////////////

func (session *Session) request(method string, requestUrl string, body io.Reader) ([]byte, error) {
	req, err := http.NewRequest(method, requestUrl, body)

	if session.ApiToken != "" {
		req.SetBasicAuth(session.ApiToken, "api_token")
	} else {
		req.SetBasicAuth(session.username, session.password)
	}

	req.Header.Add("Content-Type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	content, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode < 200 || resp.StatusCode >= 400 {
		return content, fmt.Errorf(resp.Status)
	}

	return content, nil
}

func (session *Session) get(requestUrl string, path string, params map[string]string) ([]byte, error) {
	requestUrl += path

	if params != nil {
		data := url.Values{}
		for key, value := range params {
			data.Set(key, value)
		}
		requestUrl += "?" + data.Encode()
	}

	log.Printf("GETing from URL: %s", requestUrl)
	return session.request("GET", requestUrl, nil)
}

func (session *Session) post(requestUrl string, path string, data interface{}) ([]byte, error) {
	requestUrl += path
	var body []byte
	var err error

	if data != nil {
		body, err = json.Marshal(data)
		if err != nil {
			return nil, err
		}
	}

	log.Printf("POSTing to URL: %s", requestUrl)
	log.Printf("data: %s", body)
	return session.request("POST", requestUrl, bytes.NewBuffer(body))
}

func (session *Session) put(requestUrl string, path string, data interface{}) ([]byte, error) {
	requestUrl += path
	var body []byte
	var err error

	if data != nil {
		body, err = json.Marshal(data)
		if err != nil {
			return nil, err
		}
	}

	log.Printf("PUTing to URL: %s", requestUrl)
	return session.request("PUT", requestUrl, bytes.NewBuffer(body))
}

func (session *Session) delete(requestUrl string, path string) ([]byte, error) {
	requestUrl += path
	log.Printf("DELETINGing URL: %s", requestUrl)
	return session.request("DELETE", requestUrl, nil)
}

func decodeSession(data []byte, session *Session) error {
	dec := json.NewDecoder(bytes.NewReader(data))
	err := dec.Decode(session)
	if err != nil {
		return err
	}
	return nil
}

func decodeAccount(data []byte, account *Account) error {
	dec := json.NewDecoder(bytes.NewReader(data))
	err := dec.Decode(account)
	if err != nil {
		return err
	}
	return nil
}

func decodeSummaryReport(data []byte, report *SummaryReport) error {
	log.Printf("Decoding %s", data)
	dec := json.NewDecoder(bytes.NewReader(data))
	err := dec.Decode(&report)
	if err != nil {
		return err
	}
	return nil
}

// This is an alias for TimeEntry that is used in tempTimeEntry to prevent the
// unmarshaler from infinitely recursing while unmarshaling.
type timeEntry TimeEntry

// tempTimeEntry is an intermediate type used as for decoding TimeEntries.
type tempTimeEntry struct {
	timeEntry
	Stop  string `json:"stop"`
	Start string `json:"start"`
}

func (t *tempTimeEntry) asTimeEntry() (entry TimeEntry, err error) {
	entry = TimeEntry(t.timeEntry)

	parseTime := func(s string) (t time.Time, err error) {
		t, err = time.Parse("2006-01-02T15:04:05Z", s)
		if err != nil {
			t, err = time.Parse("2006-01-02T15:04:05-07:00", s)
		}
		return
	}

	if t.Start != "" {
		var start time.Time
		start, err = parseTime(t.Start)
		if err != nil {
			return
		}
		entry.Start = &start
	}

	if t.Stop != "" {
		var stop time.Time
		stop, err = parseTime(t.Stop)
		if err != nil {
			return
		}
		entry.Stop = &stop
	}

	return
}

func timeEntryRequest(data []byte, err error) (TimeEntry, error) {
	if err != nil {
		return TimeEntry{}, err
	}

	var entry struct {
		Data TimeEntry `json:"data"`
	}
	err = json.Unmarshal(data, &entry)
	log.Printf("Unmarshaled '%s' into %#v\n", data, entry)
	if err != nil {
		return TimeEntry{}, err
	}

	return entry.Data, nil
}
